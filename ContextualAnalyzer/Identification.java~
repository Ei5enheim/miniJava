/*
 * File:    Identification.java
 * Author:  Rajesh Gopidi
 * PID:     720367703
 * Course : COMP520
 */
package miniJava.ContextualAnalyzer;

import miniJava.AbstractSyntaxTrees.*;
import miniJava.AbstractSyntaxTrees.Package;
public class Identification implements Visitor<String,Object> {
	
    public static boolean showPosition = false;
    private static boolean secondWalk = false;
    private SymbolTable table;
    private static boolean isStaticMethod = false;
    private String currentClass = null;
    private ErrorReporter reporter;
    
    public Identification() 
    {
        // we are going to use the same table for both walks as 
        // everything added in the first walk will be removed
        table = new SymbolTable();
        reporter = new ErrorReporter();
        // add the standard env here and do not forget to increment the level
    }

    public void Identify (AST ast)
    {
        // need to add the standard environment code here
        ast.visit(this, null);
        secondWalk = true;
        ast.visit(this,null);
        if (reporter.errorCount > 0)
            System.exit(4);
    }   
    
    // Package
    public Object visitPackage(Package prog, String arg) {
    
        ClassDeclList cl = prog.classDeclList;
        for (ClassDecl c: prog.classDeclList){
            c.visit(this, null);
        }
        return null;
    }
    
    
  // Declarations
    public Object visitClassDecl(ClassDecl clas, String arg){
       
        // need to add the exit(4) code in the symbol table
        table.add(clas.name, clas);
      
        if (secondWalk) {  
            table.newScope(true); 
            table.add ("this", clas);
            for (FieldDecl f: clas.fieldDeclList)
                f.visit(this, null);
    
            for (MethodDecl m: clas.methodDeclList) {
                table.add(m.name + "function", m);
            }
            currentClass = clas.name;
            for (MethodDecl m: clas.methodDeclList) {
                isStaticMethod = false;
        	m.visit(this, null);
            }
        }
        return null;
    }
    
    public Object visitFieldDecl(FieldDecl f, String arg) {
       
        f.type.visit(this, null); 
        table.add(f.name, f);
        return null;
    }
    
    public Object visitMethodDecl(MethodDecl m, String arg)
    {
        table.newScope(true); 
        isStaticMethod = m.isStatic;
        ParameterDeclList pdl = m.parameterDeclList;
        for (ParameterDecl pd: pdl) {
            pd.visit(this, null);
        }   

        StatementList sl = m.statementList;

        for (Statement s: sl) {
            s.visit(this, null);
        }
        if (m.returnExp != null) {
            m.returnExp.visit(this, null);
        }
        table.closeScope(true);
    
        return null;
    }
    
    public Object visitParameterDecl(ParameterDecl pd, String arg) 
    {
        pd.type.visit(this, null); 
        table.add(pd.name, pd);
        return null;
    } 
    
    public Object visitVarDecl(VarDecl vd, String arg)
    {
        vd.type.visit(this, null);
        table.add(vd.name, vd);
        return null;
    }
 
    // Statements
    public Object visitBlockStmt(BlockStmt stmt, String arg)
    {
        StatementList sl = stmt.sl;
        table.newScope();
        for (Statement s: sl) {
        	s.visit(this, null);
        }
        table.closeScope();
        return null;
    }
    
    public Object visitVardeclStmt(VarDeclStmt stmt, String arg){
        
        if (stmt.initExp != null)
            stmt.initExp.visit(this, null);
        stmt.varDecl.visit(this, null);
        return null;
    }
    
    public Object visitAssignStmt(AssignStmt stmt, String arg){
        stmt.ref = (Reference) stmt.ref.visit(this, "false");
        stmt.val.visit(this, null);
        return null;
    }
    
    public Object visitCallStmt(CallStmt stmt, String arg){
        stmt.methodRef = (Reference) stmt.methodRef.visit(this, "true");
        ExprList al = stmt.argList;
        for (Expression e: al) {
            e.visit(this, null);
        }
        return null;
    }
    
    public Object visitIfStmt(IfStmt stmt, String arg){
        stmt.cond.visit(this, null);
        stmt.thenStmt.visit(this, null);
        if (stmt.elseStmt != null)
            stmt.elseStmt.visit(this, null);
        return null;
    }
    
    public Object visitWhileStmt(WhileStmt stmt, String arg){
        stmt.cond.visit(this, null);
        stmt.body.visit(this, null);
        return null;
    }
    
    
  // Expressions
    public Object visitUnaryExpr(UnaryExpr expr, String arg){
        expr.operator.visit(this, null);
        expr.expr.visit(this, null);
        return null;
    }
    
    public Object visitBinaryExpr(BinaryExpr expr, String arg){
        expr.operator.visit(this, null);
        expr.left.visit(this, null);
        expr.right.visit(this, null);
        return null;
    }
    
    public Object visitRefExpr(RefExpr expr, String arg){
        expr.ref = (Reference) expr.ref.visit(this, "false");
        return null;
    }
    
    public Object visitCallExpr(CallExpr expr, String arg){
        expr.functionRef = (Reference) expr.functionRef.visit(this, "true");
        ExprList al = expr.argList;
        for (Expression e: al) {
            e.visit(this, null);
        }
        return null;
    }
    
    public Object visitLiteralExpr(LiteralExpr expr, String arg){
        expr.literal.visit(this, null);
        return null;
    }
 
    public Object visitNewArrayExpr(NewArrayExpr expr, String arg){
        expr.eltType.visit(this, null);
        expr.sizeExpr.visit(this, null);
        return null;
    }
    
    public Object visitNewObjectExpr(NewObjectExpr expr, String arg){
        expr.classtype.visit(this, null);
        return null;
    }

    //Types

    public Object visitBaseType(BaseType type, String arg){
        //show(arg, type.typeKind + " " + type.toString());
        return null;
    }

    public Object visitClassType(ClassType type, String arg)
    {
        Declaration decl = null;
        if ((decl = table.retrieveClassDecl(type.className)) == null) {
            reporter.reportError("Cannot find symbol", type.className, type.posn);
        }
        type.classDecl = (ClassDecl) decl;
        return decl;
    }

    public Object visitArrayType(ArrayType type, String arg){
        return (type.eltType.visit(this, null));
    }    
   
  // References
    
    public Object visitQualifiedRef(QualifiedRef qr, String isMCall)
    {
        Reference ref = null, ret = null;
        Declaration decl = null, classDecl = null;        
        int level = -1;
        Identifier id = null;
        String name = null, className = null;
        boolean isMethodCall = false, isStatic = false, isPrivate = false;

        if ((isMCall != null) && isMCall.equals("true"))
            isMethodCall = true;

        if (qr.thisRelative && !isStaticMethod) {
            id = new Identifier("this", qr.posn);
            id.decl = decl;
            ref = new ThisRef(id, qr.posn);
            ret = ref;
            id = null;
        } else {
            reporter.reportError("Non static variable this cannot be referenced from static method",
                                      " ", qr.posn); 
            return (qr);
        }

        IdentifierList ql = qr.qualifierList;
        if (ql.size() > 0) {
            id = ql.get(0);
            if (isMethodCall && ql.size() == 1) {
                name = id.spelling + "function";
            } else {
                name = id.spelling;
            }

            if ((decl = table.retrieve(name)) != null) {
                id.decl = decl;
            } else {
                reporter.reportError("cannot find symbol - variable-", id.spelling, id.posn);
                return (qr);
            }

            if (ref == null) {
                level = table.retrieveLevel(name);
                if (level > 2) {
                    ref = new LocalRef(id, qr.posn);
                    classDecl = retrieveClassDecl(decl);
                } else if (level == 2) {
                    if (isStaticMethod && !(((MemberDecl)decl).isStatic)) {
                        reporter.reportError("non static variable " + id.spelling + 
                                             " cannot be referenced from a static context ", 
                                             " ", id.posn);
                        return (qr);
                    } 
                    ref = new MemberRef(id, qr.posn);
                    classDecl = retrieveClassDecl(decl);
                } else if ((level == 1) && (ql.size() != 1)) {
                    ref = new ClassRef(id, qr.posn);
                    classDecl = decl;
                } else {
                    reporter.reportError("cannot find symbol - variable-", id.spelling, id.posn);
                    return (qr);
                }
                ret = ref;
            } else {
                // this ref case
                ref.ref = new DeRef(id, id.posn);
                ref = ref.ref; 
                classDecl = retrieveClassDecl(decl);
            }      
        }

        for (int i = 1; i < ql.size(); i++) {
            id = ql.get(i);
            if (classDecl == null) {
                reporter.reportError("unable to derefence - variable-", id.spelling, id.posn);
                return (qr);
            }
            name = id.spelling;
            className = classDecl.name;
            // Method name is passed as an argument
            if (isMethodCall && (i  == (ql.size() - 1))) {
                decl = retrieveMethodDeclaration(classDecl, name);
            } else {
                decl = retrieveMethodDeclaration(classDecl, name);
            }

            if (decl != null) {
                isStatic = ((MemberDecl) decl).isStatic;
                isPrivate = ((MemberDecl) decl).isPrivate;

                if (isPrivate && !className.equals(currentClass)) {
                    reporter.reportError(id.spelling + " has private access in ", className, id.posn);
                    return (qr);
                }
                id.decl = decl;
                if ((level == 1) && (i == 1) && !isStatic) {
                    reporter.reportError("non static variable " + id.spelling +
                            " cannot be referenced from a static context ",
                            " ", id.posn);
                    return (qr);
                } 
                ref.ref = new DeRef(id, id.posn);
                ref = ref.ref;
                classDecl = retrieveClassDecl(decl);
            } else {
                reporter.reportError("cannot find symbol - variable-", id.spelling, id.posn);
                return (qr);
            }    
        }

        if (((MemberDecl) decl).isStatic) {
            reporter.reportError("PA3 no static access error", id.spelling, id.posn);
            // report error "PA3 no static access error"
        }

        return ret;
    }

    public ClassDecl retrieveClassDecl (Declaration decl)
    {
        return ((ClassDecl)decl.type.visit(this, null));
    }


    // Retrieving the declaration

    public Declaration retrieveFieldDeclaration (Declaration decl, String key)
    {
        ClassDecl clas = (ClassDecl) decl;
        
        for (FieldDecl f: clas.fieldDeclList) {
            if (key.equals(f.name)) {
                return (f);
            }
        }
        return null;    
    }

    public Declaration retrieveMethodDeclaration (Declaration decl, String key)
    {
        ClassDecl clas = (ClassDecl) decl;

        for (MethodDecl m: clas.methodDeclList) {
            if (key.equals(m.name)) {
                return (m);
            }
        }
        return null;
    }
    
    public Object visitIndexedRef(IndexedRef ir, String arg) {
    	//show(arg, ir);
        ir.ref = (Reference) ir.ref.visit(this, null);
    	ir.indexExpr.visit(this, null);
    	return ir;
    }
    
  // Terminals
    public Object visitIdentifier(Identifier id, String arg){
        //show(arg, "\"" + id.spelling + "\" " + id.toString());
        return null;
    }
    
    public Object visitOperator(Operator op, String arg){
        //show(arg, "\"" + op.spelling + "\" " + op.toString());
        return null;
    }
    
    public Object visitIntLiteral(IntLiteral num, String arg){
        //show(arg, "\"" + num.spelling + "\" " + num.toString());
        return null;
    }
    
    public Object visitBooleanLiteral(BooleanLiteral bool, String arg){
        //show(arg, "\"" + bool.spelling + "\" " + bool.toString());
        return null;
    }

    /**
    public Object visitLocalRef(LocalRef ref, String arg) 
    {
        return null;
    }

    public Object visitMemberRef(MemberRef ref, String arg)
    {
        return null;
    }

    public Object visitClassRef(ClassRef ref, String arg)
    {
        return null;
    }

    public Object visitThisRef(ThisRef ref, String arg)
    {
        return null;
    }

    public Object visitDeRef(DeRef ref, String arg)
    {
        return null;
    }
    */
    public void reportError(String str) 
    {
        // add the code here 
        System.exit(4);
    }

    
}
